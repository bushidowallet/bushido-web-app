{"version":3,"sources":["lib/crypto/ecdsa.js"],"names":["integerToBytes","i","len","bytes","toByteArrayUnsigned","length","slice","unshift","ECFieldElementFp","prototype","getByteLength","Math","floor","this","toBigInteger","bitLength","ECPointFp","getEncoded","compressed","x","getX","y","getY","enc","isEven","concat","decodeFrom","curve","dataLen","xBa","yBa","BigInteger","fromBigInteger","add2D","b","isInfinity","equals","twice","getInfinity","x_x","subtract","y_y","gamma","divide","x3","square","y3","multiply","twice2D","signum","TWO","valueOf","THREE","add","a","multiply2D","k","e","h","neg","negate","R","hBit","testBit","eBit","isOnCurve","getA","getB","n","getQ","lhs","mod","rhs","toString","validate","Error","compareTo","ONE","ECDSA","implShamirsTrick","P","Q","l","m","max","Z","z","ecparams","getSECCurveByName","rng","SecureRandom","P_OVER_FOUR","getBigRandom","limit","sign","hash","priv","d","getN","fromByteArrayUnsigned","G","getG","r","ZERO","s","modInverse","serializeSig","verify","sig","pubkey","Util","isArray","obj","parseSig","getCurve","verifyRaw","c","u1","u2","point","v","rBa","toByteArraySigned","sBa","sequence","push","cursor","parseSigCompact","recoverPubKey","isYEven","isSecondKey","p","alpha","beta","modPow","eNeg","rInv","pubKey","ECKey","pub","calcPubkeyRecoveryParam","address","getBitcoinAddress"],"mappings":"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","file":"lib/crypto/ecdsa.min.js","sourcesContent":["/* jshint undef: false */\r\n\r\nfunction integerToBytes(i, len) {\r\n  var bytes = i.toByteArrayUnsigned();\r\n\r\n  if (len < bytes.length) {\r\n    bytes = bytes.slice(bytes.length-len);\r\n  } else while (len > bytes.length) {\r\n    bytes.unshift(0);\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\nECFieldElementFp.prototype.getByteLength = function () {\r\n  return Math.floor((this.toBigInteger().bitLength() + 7) / 8);\r\n};\r\n\r\nECPointFp.prototype.getEncoded = function (compressed) {\r\n  var x = this.getX().toBigInteger();\r\n  var y = this.getY().toBigInteger();\r\n\r\n  // Get value as a 32-byte Buffer\r\n  // Fixed length based on a patch by bitaddress.org and Casascius\r\n  var enc = integerToBytes(x, 32);\r\n\r\n  if (compressed) {\r\n    if (y.isEven()) {\r\n      // Compressed even pubkey\r\n      // M = 02 || X\r\n      enc.unshift(0x02);\r\n    } else {\r\n      // Compressed uneven pubkey\r\n      // M = 03 || X\r\n      enc.unshift(0x03);\r\n    }\r\n  } else {\r\n    // Uncompressed pubkey\r\n    // M = 04 || X || Y\r\n    enc.unshift(0x04);\r\n    enc = enc.concat(integerToBytes(y, 32));\r\n  }\r\n  return enc;\r\n};\r\n\r\nECPointFp.decodeFrom = function (curve, enc) {\r\n  var dataLen = enc.length-1;\r\n\r\n  // Extract x and y as byte arrays\r\n  var xBa = enc.slice(1, 1 + dataLen/2);\r\n  var yBa = enc.slice(1 + dataLen/2, 1 + dataLen);\r\n\r\n  // Prepend zero byte to prevent interpretation as negative integer\r\n  xBa.unshift(0);\r\n  yBa.unshift(0);\r\n\r\n  // Convert to BigIntegers\r\n  var x = new BigInteger(xBa);\r\n  var y = new BigInteger(yBa);\r\n\r\n  // Return point\r\n  return new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));\r\n};\r\n\r\nECPointFp.prototype.add2D = function (b) {\r\n  if(this.isInfinity()) return b;\r\n  if(b.isInfinity()) return this;\r\n\r\n  if (this.x.equals(b.x)) {\r\n    if (this.y.equals(b.y)) {\r\n      // this = b, i.e. this must be doubled\r\n      return this.twice();\r\n    }\r\n    // this = -b, i.e. the result is the point at infinity\r\n    return this.curve.getInfinity();\r\n  }\r\n\r\n  var x_x = b.x.subtract(this.x);\r\n  var y_y = b.y.subtract(this.y);\r\n  var gamma = y_y.divide(x_x);\r\n\r\n  var x3 = gamma.square().subtract(this.x).subtract(b.x);\r\n  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);\r\n\r\n  return new ECPointFp(this.curve, x3, y3);\r\n};\r\n\r\nECPointFp.prototype.twice2D = function () {\r\n  if (this.isInfinity()) return this;\r\n  if (this.y.toBigInteger().signum() === 0) {\r\n    // if y1 == 0, then (x1, y1) == (x1, -y1)\r\n    // and hence this = -this and thus 2(x1, y1) == infinity\r\n    return this.curve.getInfinity();\r\n  }\r\n\r\n  var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));\r\n  var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));\r\n  var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));\r\n\r\n  var x3 = gamma.square().subtract(this.x.multiply(TWO));\r\n  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);\r\n\r\n  return new ECPointFp(this.curve, x3, y3);\r\n};\r\n\r\nECPointFp.prototype.multiply2D = function (k) {\r\n  if(this.isInfinity()) return this;\r\n  if(k.signum() === 0) return this.curve.getInfinity();\r\n\r\n  var e = k;\r\n  var h = e.multiply(new BigInteger(\"3\"));\r\n\r\n  var neg = this.negate();\r\n  var R = this;\r\n\r\n  var i;\r\n  for (i = h.bitLength() - 2; i > 0; --i) {\r\n    R = R.twice();\r\n\r\n    var hBit = h.testBit(i);\r\n    var eBit = e.testBit(i);\r\n\r\n    if (hBit != eBit) {\r\n      R = R.add2D(hBit ? this : neg);\r\n    }\r\n  }\r\n\r\n  return R;\r\n};\r\n\r\nECPointFp.prototype.isOnCurve = function () {\r\n  var x = this.getX().toBigInteger();\r\n  var y = this.getY().toBigInteger();\r\n  var a = this.curve.getA().toBigInteger();\r\n  var b = this.curve.getB().toBigInteger();\r\n  var n = this.curve.getQ();\r\n  var lhs = y.multiply(y).mod(n);\r\n  var rhs = x.multiply(x).multiply(x)\r\n    .add(a.multiply(x)).add(b).mod(n);\r\n  return lhs.equals(rhs);\r\n};\r\n\r\nECPointFp.prototype.toString = function () {\r\n  return '('+this.getX().toBigInteger().toString()+','+\r\n    this.getY().toBigInteger().toString()+')';\r\n};\r\n\r\n/**\r\n * Validate an elliptic curve point.\r\n *\r\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\r\n */\r\nECPointFp.prototype.validate = function () {\r\n  var n = this.curve.getQ();\r\n\r\n  // Check Q != O\r\n  if (this.isInfinity()) {\r\n    throw new Error(\"Point is at infinity.\");\r\n  }\r\n\r\n  // Check coordinate bounds\r\n  var x = this.getX().toBigInteger();\r\n  var y = this.getY().toBigInteger();\r\n  if (x.compareTo(BigInteger.ONE) < 0 ||\r\n      x.compareTo(n.subtract(BigInteger.ONE)) > 0) {\r\n    throw new Error('x coordinate out of bounds');\r\n  }\r\n  if (y.compareTo(BigInteger.ONE) < 0 ||\r\n      y.compareTo(n.subtract(BigInteger.ONE)) > 0) {\r\n    throw new Error('y coordinate out of bounds');\r\n  }\r\n\r\n  // Check y^2 = x^3 + ax + b (mod n)\r\n  if (!this.isOnCurve()) {\r\n    throw new Error(\"Point is not on the curve.\");\r\n  }\r\n\r\n  // Check nQ = 0 (Q is a scalar multiple of G)\r\n  if (this.multiply(n).isInfinity()) {\r\n    // TODO: This check doesn't work - fix.\r\n    throw new Error(\"Point is not a scalar multiple of G.\");\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nECDSA = (function () {\r\n  var ecparams = getSECCurveByName(\"secp256k1\");\r\n  var rng = new SecureRandom();\r\n\r\n  var P_OVER_FOUR = null;\r\n\r\n  function implShamirsTrick(P, k, Q, l)\r\n  {\r\n    var m = Math.max(k.bitLength(), l.bitLength());\r\n    var Z = P.add2D(Q);\r\n    var R = P.curve.getInfinity();\r\n\r\n    for (var i = m - 1; i >= 0; --i) {\r\n      R = R.twice2D();\r\n\r\n      R.z = BigInteger.ONE;\r\n\r\n      if (k.testBit(i)) {\r\n        if (l.testBit(i)) {\r\n          R = R.add2D(Z);\r\n        } else {\r\n          R = R.add2D(P);\r\n        }\r\n      } else {\r\n        if (l.testBit(i)) {\r\n          R = R.add2D(Q);\r\n        }\r\n      }\r\n    }\r\n\r\n    return R;\r\n  }\r\n\r\n  var ECDSA = {\r\n    getBigRandom: function (limit) {\r\n      return new BigInteger(limit.bitLength(), rng)\r\n        .mod(limit.subtract(BigInteger.ONE))\r\n        .add(BigInteger.ONE)\r\n      ;\r\n    },\r\n    sign: function (hash, priv) {\r\n      var d = priv;\r\n      var n = ecparams.getN();\r\n      var e = BigInteger.fromByteArrayUnsigned(hash);\r\n\r\n      do {\r\n        var k = ECDSA.getBigRandom(n);\r\n        var G = ecparams.getG();\r\n        var Q = G.multiply(k);\r\n        var r = Q.getX().toBigInteger().mod(n);\r\n      } while (r.compareTo(BigInteger.ZERO) <= 0);\r\n\r\n      var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\r\n\r\n      return ECDSA.serializeSig(r, s);\r\n    },\r\n\r\n    verify: function (hash, sig, pubkey) {\r\n      var r,s;\r\n      if (Util.isArray(sig)) {\r\n        var obj = ECDSA.parseSig(sig);\r\n        r = obj.r;\r\n        s = obj.s;\r\n      } else if (\"object\" === typeof sig && sig.r && sig.s) {\r\n        r = sig.r;\r\n        s = sig.s;\r\n      } else {\r\n        throw \"Invalid value for signature\";\r\n      }\r\n\r\n      var Q;\r\n      if (pubkey instanceof ECPointFp) {\r\n        Q = pubkey;\r\n      } else if (Util.isArray(pubkey)) {\r\n        Q = ECPointFp.decodeFrom(ecparams.getCurve(), pubkey);\r\n      } else {\r\n        throw \"Invalid format for pubkey value, must be byte array or ECPointFp\";\r\n      }\r\n      var e = BigInteger.fromByteArrayUnsigned(hash);\r\n\r\n      return ECDSA.verifyRaw(e, r, s, Q);\r\n    },\r\n\r\n    verifyRaw: function (e, r, s, Q) {\r\n      var n = ecparams.getN();\r\n      var G = ecparams.getG();\r\n\r\n      if (r.compareTo(BigInteger.ONE) < 0 ||\r\n          r.compareTo(n) >= 0)\r\n        return false;\r\n\r\n      if (s.compareTo(BigInteger.ONE) < 0 ||\r\n          s.compareTo(n) >= 0)\r\n        return false;\r\n\r\n      var c = s.modInverse(n);\r\n\r\n      var u1 = e.multiply(c).mod(n);\r\n      var u2 = r.multiply(c).mod(n);\r\n\r\n      // TODO(!!!): For some reason Shamir's trick isn't working with\r\n      // signed message verification!? Probably an implementation\r\n      // error!\r\n      //var point = implShamirsTrick(G, u1, Q, u2);\r\n      var point = G.multiply(u1).add(Q.multiply(u2));\r\n\r\n      var v = point.getX().toBigInteger().mod(n);\r\n\r\n      return v.equals(r);\r\n    },\r\n\r\n    /**\r\n     * Serialize a signature into DER format.\r\n     *\r\n     * Takes two BigIntegers representing r and s and returns a byte array.\r\n     */\r\n    serializeSig: function (r, s) {\r\n      var rBa = r.toByteArraySigned();\r\n      var sBa = s.toByteArraySigned();\r\n\r\n      var sequence = [];\r\n      sequence.push(0x02); // INTEGER\r\n      sequence.push(rBa.length);\r\n      sequence = sequence.concat(rBa);\r\n\r\n      sequence.push(0x02); // INTEGER\r\n      sequence.push(sBa.length);\r\n      sequence = sequence.concat(sBa);\r\n\r\n      sequence.unshift(sequence.length);\r\n      sequence.unshift(0x30); // SEQUENCE\r\n\r\n      return sequence;\r\n    },\r\n\r\n    /**\r\n     * Parses a byte array containing a DER-encoded signature.\r\n     *\r\n     * This function will return an object of the form:\r\n     *\r\n     * {\r\n     *   r: BigInteger,\r\n     *   s: BigInteger\r\n     * }\r\n     */\r\n    parseSig: function (sig) {\r\n      var cursor;\r\n      if (sig[0] != 0x30)\r\n        throw new Error(\"Signature not a valid DERSequence\");\r\n\r\n      cursor = 2;\r\n      if (sig[cursor] != 0x02)\r\n        throw new Error(\"First element in signature must be a DERInteger\");\r\n      var rBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);\r\n\r\n      cursor += 2+sig[cursor+1];\r\n      if (sig[cursor] != 0x02)\r\n        throw new Error(\"Second element in signature must be a DERInteger\");\r\n      var sBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);\r\n\r\n      cursor += 2+sig[cursor+1];\r\n\r\n      //if (cursor != sig.length)\r\n      //  throw new Error(\"Extra bytes in signature\");\r\n\r\n      var r = BigInteger.fromByteArrayUnsigned(rBa);\r\n      var s = BigInteger.fromByteArrayUnsigned(sBa);\r\n\r\n      return {r: r, s: s};\r\n    },\r\n\r\n    parseSigCompact: function (sig) {\r\n      if (sig.length !== 65) {\r\n        throw \"Signature has the wrong length\";\r\n      }\r\n\r\n      // Signature is prefixed with a type byte storing three bits of\r\n      // information.\r\n      var i = sig[0] - 27;\r\n      if (i < 0 || i > 7) {\r\n        throw \"Invalid signature type\";\r\n      }\r\n\r\n      var n = ecparams.getN();\r\n      var r = BigInteger.fromByteArrayUnsigned(sig.slice(1, 33)).mod(n);\r\n      var s = BigInteger.fromByteArrayUnsigned(sig.slice(33, 65)).mod(n);\r\n\r\n      return {r: r, s: s, i: i};\r\n    },\r\n\r\n    /**\r\n     * Recover a public key from a signature.\r\n     *\r\n     * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\r\n     * Key Recovery Operation\".\r\n     *\r\n     * http://www.secg.org/download/aid-780/sec1-v2.pdf\r\n     */\r\n    recoverPubKey: function (r, s, hash, i) {\r\n      // The recovery parameter i has two bits.\r\n      i = i & 3;\r\n\r\n      // The less significant bit specifies whether the y coordinate\r\n      // of the compressed point is even or not.\r\n      var isYEven = i & 1;\r\n\r\n      // The more significant bit specifies whether we should use the\r\n      // first or second candidate key.\r\n      var isSecondKey = i >> 1;\r\n\r\n      var n = ecparams.getN();\r\n      var G = ecparams.getG();\r\n      var curve = ecparams.getCurve();\r\n      var p = curve.getQ();\r\n      var a = curve.getA().toBigInteger();\r\n      var b = curve.getB().toBigInteger();\r\n\r\n      // We precalculate (p + 1) / 4 where p is if the field order\r\n      if (!P_OVER_FOUR) {\r\n        P_OVER_FOUR = p.add(BigInteger.ONE).divide(BigInteger.valueOf(4));\r\n      }\r\n\r\n      // 1.1 Compute x\r\n      var x = isSecondKey ? r.add(n) : r;\r\n\r\n      // 1.3 Convert x to point\r\n      var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);\r\n      var beta = alpha.modPow(P_OVER_FOUR, p);\r\n\r\n      // If beta is even, but y isn't or vice versa, then convert it,\r\n      // otherwise we're done and y == beta.\r\n      var y = (beta.isEven() ? !isYEven : isYEven) ? beta : p.subtract(beta);\r\n\r\n      // 1.4 Check that nR is at infinity\r\n      var R = new ECPointFp(curve,\r\n                            curve.fromBigInteger(x),\r\n                            curve.fromBigInteger(y));\r\n      R.validate();\r\n\r\n      // 1.5 Compute e from M\r\n      var e = BigInteger.fromByteArrayUnsigned(hash);\r\n      var eNeg = BigInteger.ZERO.subtract(e).mod(n);\r\n\r\n      // 1.6 Compute Q = r^-1 (sR - eG)\r\n      var rInv = r.modInverse(n);\r\n      var Q = implShamirsTrick(R, s, G, eNeg).multiply(rInv);\r\n\r\n      Q.validate();\r\n      if (!ECDSA.verifyRaw(e, r, s, Q)) {\r\n        throw \"Pubkey recovery unsuccessful\";\r\n      }\r\n\r\n      var pubKey = new ECKey();\r\n      pubKey.pub = Q;\r\n      return pubKey;\r\n    },\r\n\r\n    /**\r\n     * Calculate pubkey extraction parameter.\r\n     *\r\n     * When extracting a pubkey from a signature, we have to\r\n     * distinguish four different cases. Rather than putting this\r\n     * burden on the verifier, Bitcoin includes a 2-bit value with the\r\n     * signature.\r\n     *\r\n     * This function simply tries all four cases and returns the value\r\n     * that resulted in a successful pubkey recovery.\r\n     */\r\n    calcPubkeyRecoveryParam: function (address, r, s, hash)\r\n    {\r\n      for (var i = 0; i < 4; i++) {\r\n        try {\r\n          var pubkey = ECDSA.recoverPubKey(r, s, hash, i);\r\n          if (pubkey.getBitcoinAddress().toString() == address) {\r\n            return i;\r\n          }\r\n        } catch (e) {}\r\n      }\r\n      throw \"Unable to find valid recovery factor\";\r\n    }\r\n  };\r\n\r\n  return ECDSA;\r\n})();\r\n"],"sourceRoot":"/source/"}