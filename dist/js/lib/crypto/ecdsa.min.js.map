{"version":3,"sources":["lib/crypto/ecdsa.js"],"names":["integerToBytes","i","len","bytes","toByteArrayUnsigned","length","slice","unshift","ECFieldElementFp","prototype","getByteLength","Math","floor","this","toBigInteger","bitLength","ECPointFp","getEncoded","compressed","x","getX","y","getY","enc","isEven","concat","decodeFrom","curve","dataLen","xBa","yBa","BigInteger","fromBigInteger","add2D","b","isInfinity","equals","twice","getInfinity","x_x","subtract","y_y","gamma","divide","x3","square","y3","multiply","twice2D","signum","TWO","valueOf","THREE","add","a","multiply2D","k","e","h","neg","negate","R","hBit","testBit","eBit","isOnCurve","getA","getB","n","getQ","lhs","mod","rhs","toString","validate","Error","compareTo","ONE","ECDSA","implShamirsTrick","P","Q","l","m","max","Z","z","ecparams","getSECCurveByName","rng","SecureRandom","P_OVER_FOUR","getBigRandom","limit","sign","hash","priv","d","getN","fromByteArrayUnsigned","G","getG","r","ZERO","s","modInverse","serializeSig","verify","sig","pubkey","Util","isArray","obj","parseSig","getCurve","verifyRaw","c","u1","u2","point","v","rBa","toByteArraySigned","sBa","sequence","push","cursor","parseSigCompact","recoverPubKey","isYEven","isSecondKey","p","alpha","beta","modPow","eNeg","rInv","pubKey","ECKey","pub","calcPubkeyRecoveryParam","address","getBitcoinAddress"],"mappings":"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","file":"lib/crypto/ecdsa.min.js","sourcesContent":["/* jshint undef: false */\n\nfunction integerToBytes(i, len) {\n  var bytes = i.toByteArrayUnsigned();\n\n  if (len < bytes.length) {\n    bytes = bytes.slice(bytes.length-len);\n  } else while (len > bytes.length) {\n    bytes.unshift(0);\n  }\n\n  return bytes;\n}\n\nECFieldElementFp.prototype.getByteLength = function () {\n  return Math.floor((this.toBigInteger().bitLength() + 7) / 8);\n};\n\nECPointFp.prototype.getEncoded = function (compressed) {\n  var x = this.getX().toBigInteger();\n  var y = this.getY().toBigInteger();\n\n  // Get value as a 32-byte Buffer\n  // Fixed length based on a patch by bitaddress.org and Casascius\n  var enc = integerToBytes(x, 32);\n\n  if (compressed) {\n    if (y.isEven()) {\n      // Compressed even pubkey\n      // M = 02 || X\n      enc.unshift(0x02);\n    } else {\n      // Compressed uneven pubkey\n      // M = 03 || X\n      enc.unshift(0x03);\n    }\n  } else {\n    // Uncompressed pubkey\n    // M = 04 || X || Y\n    enc.unshift(0x04);\n    enc = enc.concat(integerToBytes(y, 32));\n  }\n  return enc;\n};\n\nECPointFp.decodeFrom = function (curve, enc) {\n  var dataLen = enc.length-1;\n\n  // Extract x and y as byte arrays\n  var xBa = enc.slice(1, 1 + dataLen/2);\n  var yBa = enc.slice(1 + dataLen/2, 1 + dataLen);\n\n  // Prepend zero byte to prevent interpretation as negative integer\n  xBa.unshift(0);\n  yBa.unshift(0);\n\n  // Convert to BigIntegers\n  var x = new BigInteger(xBa);\n  var y = new BigInteger(yBa);\n\n  // Return point\n  return new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));\n};\n\nECPointFp.prototype.add2D = function (b) {\n  if(this.isInfinity()) return b;\n  if(b.isInfinity()) return this;\n\n  if (this.x.equals(b.x)) {\n    if (this.y.equals(b.y)) {\n      // this = b, i.e. this must be doubled\n      return this.twice();\n    }\n    // this = -b, i.e. the result is the point at infinity\n    return this.curve.getInfinity();\n  }\n\n  var x_x = b.x.subtract(this.x);\n  var y_y = b.y.subtract(this.y);\n  var gamma = y_y.divide(x_x);\n\n  var x3 = gamma.square().subtract(this.x).subtract(b.x);\n  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);\n\n  return new ECPointFp(this.curve, x3, y3);\n};\n\nECPointFp.prototype.twice2D = function () {\n  if (this.isInfinity()) return this;\n  if (this.y.toBigInteger().signum() === 0) {\n    // if y1 == 0, then (x1, y1) == (x1, -y1)\n    // and hence this = -this and thus 2(x1, y1) == infinity\n    return this.curve.getInfinity();\n  }\n\n  var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));\n  var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));\n  var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));\n\n  var x3 = gamma.square().subtract(this.x.multiply(TWO));\n  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);\n\n  return new ECPointFp(this.curve, x3, y3);\n};\n\nECPointFp.prototype.multiply2D = function (k) {\n  if(this.isInfinity()) return this;\n  if(k.signum() === 0) return this.curve.getInfinity();\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n\n  var neg = this.negate();\n  var R = this;\n\n  var i;\n  for (i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit != eBit) {\n      R = R.add2D(hBit ? this : neg);\n    }\n  }\n\n  return R;\n};\n\nECPointFp.prototype.isOnCurve = function () {\n  var x = this.getX().toBigInteger();\n  var y = this.getY().toBigInteger();\n  var a = this.curve.getA().toBigInteger();\n  var b = this.curve.getB().toBigInteger();\n  var n = this.curve.getQ();\n  var lhs = y.multiply(y).mod(n);\n  var rhs = x.multiply(x).multiply(x)\n    .add(a.multiply(x)).add(b).mod(n);\n  return lhs.equals(rhs);\n};\n\nECPointFp.prototype.toString = function () {\n  return '('+this.getX().toBigInteger().toString()+','+\n    this.getY().toBigInteger().toString()+')';\n};\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nECPointFp.prototype.validate = function () {\n  var n = this.curve.getQ();\n\n  // Check Q != O\n  if (this.isInfinity()) {\n    throw new Error(\"Point is at infinity.\");\n  }\n\n  // Check coordinate bounds\n  var x = this.getX().toBigInteger();\n  var y = this.getY().toBigInteger();\n  if (x.compareTo(BigInteger.ONE) < 0 ||\n      x.compareTo(n.subtract(BigInteger.ONE)) > 0) {\n    throw new Error('x coordinate out of bounds');\n  }\n  if (y.compareTo(BigInteger.ONE) < 0 ||\n      y.compareTo(n.subtract(BigInteger.ONE)) > 0) {\n    throw new Error('y coordinate out of bounds');\n  }\n\n  // Check y^2 = x^3 + ax + b (mod n)\n  if (!this.isOnCurve()) {\n    throw new Error(\"Point is not on the curve.\");\n  }\n\n  // Check nQ = 0 (Q is a scalar multiple of G)\n  if (this.multiply(n).isInfinity()) {\n    // TODO: This check doesn't work - fix.\n    throw new Error(\"Point is not a scalar multiple of G.\");\n  }\n\n  return true;\n};\n\nECDSA = (function () {\n  var ecparams = getSECCurveByName(\"secp256k1\");\n  var rng = new SecureRandom();\n\n  var P_OVER_FOUR = null;\n\n  function implShamirsTrick(P, k, Q, l)\n  {\n    var m = Math.max(k.bitLength(), l.bitLength());\n    var Z = P.add2D(Q);\n    var R = P.curve.getInfinity();\n\n    for (var i = m - 1; i >= 0; --i) {\n      R = R.twice2D();\n\n      R.z = BigInteger.ONE;\n\n      if (k.testBit(i)) {\n        if (l.testBit(i)) {\n          R = R.add2D(Z);\n        } else {\n          R = R.add2D(P);\n        }\n      } else {\n        if (l.testBit(i)) {\n          R = R.add2D(Q);\n        }\n      }\n    }\n\n    return R;\n  }\n\n  var ECDSA = {\n    getBigRandom: function (limit) {\n      return new BigInteger(limit.bitLength(), rng)\n        .mod(limit.subtract(BigInteger.ONE))\n        .add(BigInteger.ONE)\n      ;\n    },\n    sign: function (hash, priv) {\n      var d = priv;\n      var n = ecparams.getN();\n      var e = BigInteger.fromByteArrayUnsigned(hash);\n\n      do {\n        var k = ECDSA.getBigRandom(n);\n        var G = ecparams.getG();\n        var Q = G.multiply(k);\n        var r = Q.getX().toBigInteger().mod(n);\n      } while (r.compareTo(BigInteger.ZERO) <= 0);\n\n      var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n\n      return ECDSA.serializeSig(r, s);\n    },\n\n    verify: function (hash, sig, pubkey) {\n      var r,s;\n      if (Util.isArray(sig)) {\n        var obj = ECDSA.parseSig(sig);\n        r = obj.r;\n        s = obj.s;\n      } else if (\"object\" === typeof sig && sig.r && sig.s) {\n        r = sig.r;\n        s = sig.s;\n      } else {\n        throw \"Invalid value for signature\";\n      }\n\n      var Q;\n      if (pubkey instanceof ECPointFp) {\n        Q = pubkey;\n      } else if (Util.isArray(pubkey)) {\n        Q = ECPointFp.decodeFrom(ecparams.getCurve(), pubkey);\n      } else {\n        throw \"Invalid format for pubkey value, must be byte array or ECPointFp\";\n      }\n      var e = BigInteger.fromByteArrayUnsigned(hash);\n\n      return ECDSA.verifyRaw(e, r, s, Q);\n    },\n\n    verifyRaw: function (e, r, s, Q) {\n      var n = ecparams.getN();\n      var G = ecparams.getG();\n\n      if (r.compareTo(BigInteger.ONE) < 0 ||\n          r.compareTo(n) >= 0)\n        return false;\n\n      if (s.compareTo(BigInteger.ONE) < 0 ||\n          s.compareTo(n) >= 0)\n        return false;\n\n      var c = s.modInverse(n);\n\n      var u1 = e.multiply(c).mod(n);\n      var u2 = r.multiply(c).mod(n);\n\n      // TODO(!!!): For some reason Shamir's trick isn't working with\n      // signed message verification!? Probably an implementation\n      // error!\n      //var point = implShamirsTrick(G, u1, Q, u2);\n      var point = G.multiply(u1).add(Q.multiply(u2));\n\n      var v = point.getX().toBigInteger().mod(n);\n\n      return v.equals(r);\n    },\n\n    /**\n     * Serialize a signature into DER format.\n     *\n     * Takes two BigIntegers representing r and s and returns a byte array.\n     */\n    serializeSig: function (r, s) {\n      var rBa = r.toByteArraySigned();\n      var sBa = s.toByteArraySigned();\n\n      var sequence = [];\n      sequence.push(0x02); // INTEGER\n      sequence.push(rBa.length);\n      sequence = sequence.concat(rBa);\n\n      sequence.push(0x02); // INTEGER\n      sequence.push(sBa.length);\n      sequence = sequence.concat(sBa);\n\n      sequence.unshift(sequence.length);\n      sequence.unshift(0x30); // SEQUENCE\n\n      return sequence;\n    },\n\n    /**\n     * Parses a byte array containing a DER-encoded signature.\n     *\n     * This function will return an object of the form:\n     *\n     * {\n     *   r: BigInteger,\n     *   s: BigInteger\n     * }\n     */\n    parseSig: function (sig) {\n      var cursor;\n      if (sig[0] != 0x30)\n        throw new Error(\"Signature not a valid DERSequence\");\n\n      cursor = 2;\n      if (sig[cursor] != 0x02)\n        throw new Error(\"First element in signature must be a DERInteger\");\n      var rBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);\n\n      cursor += 2+sig[cursor+1];\n      if (sig[cursor] != 0x02)\n        throw new Error(\"Second element in signature must be a DERInteger\");\n      var sBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);\n\n      cursor += 2+sig[cursor+1];\n\n      //if (cursor != sig.length)\n      //  throw new Error(\"Extra bytes in signature\");\n\n      var r = BigInteger.fromByteArrayUnsigned(rBa);\n      var s = BigInteger.fromByteArrayUnsigned(sBa);\n\n      return {r: r, s: s};\n    },\n\n    parseSigCompact: function (sig) {\n      if (sig.length !== 65) {\n        throw \"Signature has the wrong length\";\n      }\n\n      // Signature is prefixed with a type byte storing three bits of\n      // information.\n      var i = sig[0] - 27;\n      if (i < 0 || i > 7) {\n        throw \"Invalid signature type\";\n      }\n\n      var n = ecparams.getN();\n      var r = BigInteger.fromByteArrayUnsigned(sig.slice(1, 33)).mod(n);\n      var s = BigInteger.fromByteArrayUnsigned(sig.slice(33, 65)).mod(n);\n\n      return {r: r, s: s, i: i};\n    },\n\n    /**\n     * Recover a public key from a signature.\n     *\n     * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n     * Key Recovery Operation\".\n     *\n     * http://www.secg.org/download/aid-780/sec1-v2.pdf\n     */\n    recoverPubKey: function (r, s, hash, i) {\n      // The recovery parameter i has two bits.\n      i = i & 3;\n\n      // The less significant bit specifies whether the y coordinate\n      // of the compressed point is even or not.\n      var isYEven = i & 1;\n\n      // The more significant bit specifies whether we should use the\n      // first or second candidate key.\n      var isSecondKey = i >> 1;\n\n      var n = ecparams.getN();\n      var G = ecparams.getG();\n      var curve = ecparams.getCurve();\n      var p = curve.getQ();\n      var a = curve.getA().toBigInteger();\n      var b = curve.getB().toBigInteger();\n\n      // We precalculate (p + 1) / 4 where p is if the field order\n      if (!P_OVER_FOUR) {\n        P_OVER_FOUR = p.add(BigInteger.ONE).divide(BigInteger.valueOf(4));\n      }\n\n      // 1.1 Compute x\n      var x = isSecondKey ? r.add(n) : r;\n\n      // 1.3 Convert x to point\n      var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);\n      var beta = alpha.modPow(P_OVER_FOUR, p);\n\n      // If beta is even, but y isn't or vice versa, then convert it,\n      // otherwise we're done and y == beta.\n      var y = (beta.isEven() ? !isYEven : isYEven) ? beta : p.subtract(beta);\n\n      // 1.4 Check that nR is at infinity\n      var R = new ECPointFp(curve,\n                            curve.fromBigInteger(x),\n                            curve.fromBigInteger(y));\n      R.validate();\n\n      // 1.5 Compute e from M\n      var e = BigInteger.fromByteArrayUnsigned(hash);\n      var eNeg = BigInteger.ZERO.subtract(e).mod(n);\n\n      // 1.6 Compute Q = r^-1 (sR - eG)\n      var rInv = r.modInverse(n);\n      var Q = implShamirsTrick(R, s, G, eNeg).multiply(rInv);\n\n      Q.validate();\n      if (!ECDSA.verifyRaw(e, r, s, Q)) {\n        throw \"Pubkey recovery unsuccessful\";\n      }\n\n      var pubKey = new ECKey();\n      pubKey.pub = Q;\n      return pubKey;\n    },\n\n    /**\n     * Calculate pubkey extraction parameter.\n     *\n     * When extracting a pubkey from a signature, we have to\n     * distinguish four different cases. Rather than putting this\n     * burden on the verifier, Bitcoin includes a 2-bit value with the\n     * signature.\n     *\n     * This function simply tries all four cases and returns the value\n     * that resulted in a successful pubkey recovery.\n     */\n    calcPubkeyRecoveryParam: function (address, r, s, hash)\n    {\n      for (var i = 0; i < 4; i++) {\n        try {\n          var pubkey = ECDSA.recoverPubKey(r, s, hash, i);\n          if (pubkey.getBitcoinAddress().toString() == address) {\n            return i;\n          }\n        } catch (e) {}\n      }\n      throw \"Unable to find valid recovery factor\";\n    }\n  };\n\n  return ECDSA;\n})();\n"],"sourceRoot":"/source/"}