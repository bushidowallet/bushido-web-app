{"version":3,"sources":["lib/crypto/base58.js"],"names":["Base58","alphabet","validRegex","base","BigInteger","valueOf","encode","input","bi","fromByteArrayUnsigned","chars","compareTo","mod","unshift","intValue","subtract","divide","i","length","join","decode","leadingZerosNum","alphaIndex","indexOf","add","multiply","pow","bytes","toByteArrayUnsigned"],"mappings":"CAQA,WACEA,QACEC,SAAU,6DACVC,WAAY,0BACZC,KAAMC,WAAWC,QAAQ,IACzBC,OAAQ,SAAUC,OAIhB,IAHA,GAAIC,IAAKJ,WAAWK,sBAAsBF,OACtCG,SAEGF,GAAGG,UAAUX,OAAOG,OAAS,GAAG,CACrC,GAAIS,KAAMJ,GAAGI,IAAIZ,OAAOG,KACxBO,OAAMG,QAAQb,OAAOC,SAASW,IAAIE,aAClCN,GAAKA,GAAGO,SAASH,KAAKI,OAAOhB,OAAOG,MAEtCO,MAAMG,QAAQb,OAAOC,SAASO,GAAGM,YAGjC,KAAK,GAAIG,GAAI,EAAGA,EAAIV,MAAMW,QACR,GAAZX,MAAMU,GADsBA,IAE9BP,MAAMG,QAAQb,OAAOC,SAAS,GAIlC,OAAOS,OAAMS,KAAK,KAEpBC,OAAQ,SAAUb,OAGhB,IAAK,GAFDC,IAAKJ,WAAWC,QAAQ,GACxBgB,gBAAkB,EACbJ,EAAIV,MAAMW,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC1C,GAAIK,YAAatB,OAAOC,SAASsB,QAAQhB,MAAMU,GAC/C,IAAiB,EAAbK,WACF,KAAM,mBAERd,IAAKA,GAAGgB,IAAIpB,WAAWC,QAAQiB,YAClBG,SAASzB,OAAOG,KAAKuB,IAAInB,MAAMW,OAAS,EAAGD,KAGxC,KAAZV,MAAMU,GAAWI,kBAChBA,gBAAkB,EAKzB,IAHA,GAAIM,OAAQnB,GAAGoB,sBAGRP,mBAAoB,GAAGM,MAAMd,QAAQ,EAE5C,OAAOc","file":"lib/crypto/base58.min.js","sourcesContent":["/**\n * Convert a byte array to a base58-encoded string.\n *\n * Written by Mike Hearn for BitcoinJ.\n *   Copyright (c) 2011 Google Inc.\n *\n * Ported to JavaScript by Stefan Thomas.\n */\n(function () {\n  Base58 = {\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\",\n    validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,\n    base: BigInteger.valueOf(58),\n    encode: function (input) {\n      var bi = BigInteger.fromByteArrayUnsigned(input);\n      var chars = [];\n\n      while (bi.compareTo(Base58.base) >= 0) {\n        var mod = bi.mod(Base58.base);\n        chars.unshift(Base58.alphabet[mod.intValue()]);\n        bi = bi.subtract(mod).divide(Base58.base);\n      }\n      chars.unshift(Base58.alphabet[bi.intValue()]);\n\n      // Convert leading zeros too.\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] == 0x00) {\n          chars.unshift(Base58.alphabet[0]);\n        } else break;\n      }\n\n      return chars.join('');\n    },\n    decode: function (input) {\n      var bi = BigInteger.valueOf(0);\n      var leadingZerosNum = 0;\n      for (var i = input.length - 1; i >= 0; i--) {\n        var alphaIndex = Base58.alphabet.indexOf(input[i]);\n        if (alphaIndex < 0) {\n          throw \"Invalid character\";\n        }\t\n        bi = bi.add(BigInteger.valueOf(alphaIndex)\n                    .multiply(Base58.base.pow(input.length - 1 -i)));\n\n        // This counts leading zero bytes\n        if (input[i] == \"1\") leadingZerosNum++;\n        else leadingZerosNum = 0;\n      }\n      var bytes = bi.toByteArrayUnsigned();\n\n      // Add leading zeros\n      while (leadingZerosNum-- > 0) bytes.unshift(0);\n\n      return bytes;\n    }\n  };\n})();"],"sourceRoot":"/source/"}