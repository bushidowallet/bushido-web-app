{"version":3,"sources":["lib/crypto/base58.js"],"names":["Base58","alphabet","validRegex","base","BigInteger","valueOf","encode","input","bi","fromByteArrayUnsigned","chars","compareTo","mod","unshift","intValue","subtract","divide","i","length","join","decode","leadingZerosNum","alphaIndex","indexOf","add","multiply","pow","bytes","toByteArrayUnsigned"],"mappings":"CAQA,WACEA,QACEC,SAAU,6DACVC,WAAY,0BACZC,KAAMC,WAAWC,QAAQ,IACzBC,OAAQ,SAAUC,OAIhB,IAHA,GAAIC,IAAKJ,WAAWK,sBAAsBF,OACtCG,SAEGF,GAAGG,UAAUX,OAAOG,OAAS,GAAG,CACrC,GAAIS,KAAMJ,GAAGI,IAAIZ,OAAOG,KACxBO,OAAMG,QAAQb,OAAOC,SAASW,IAAIE,aAClCN,GAAKA,GAAGO,SAASH,KAAKI,OAAOhB,OAAOG,MAEtCO,MAAMG,QAAQb,OAAOC,SAASO,GAAGM,YAGjC,KAAK,GAAIG,GAAI,EAAGA,EAAIV,MAAMW,QACR,GAAZX,MAAMU,GADsBA,IAE9BP,MAAMG,QAAQb,OAAOC,SAAS,GAIlC,OAAOS,OAAMS,KAAK,KAEpBC,OAAQ,SAAUb,OAGhB,IAAK,GAFDC,IAAKJ,WAAWC,QAAQ,GACxBgB,gBAAkB,EACbJ,EAAIV,MAAMW,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC1C,GAAIK,YAAatB,OAAOC,SAASsB,QAAQhB,MAAMU,GAC/C,IAAiB,EAAbK,WACF,KAAM,mBAERd,IAAKA,GAAGgB,IAAIpB,WAAWC,QAAQiB,YAClBG,SAASzB,OAAOG,KAAKuB,IAAInB,MAAMW,OAAS,EAAGD,KAGxC,KAAZV,MAAMU,GAAWI,kBAChBA,gBAAkB,EAKzB,IAHA,GAAIM,OAAQnB,GAAGoB,sBAGRP,mBAAoB,GAAGM,MAAMd,QAAQ,EAE5C,OAAOc","file":"lib/crypto/base58.min.js","sourcesContent":["/**\r\n * Convert a byte array to a base58-encoded string.\r\n *\r\n * Written by Mike Hearn for BitcoinJ.\r\n *   Copyright (c) 2011 Google Inc.\r\n *\r\n * Ported to JavaScript by Stefan Thomas.\r\n */\r\n(function () {\r\n  Base58 = {\r\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\",\r\n    validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,\r\n    base: BigInteger.valueOf(58),\r\n    encode: function (input) {\r\n      var bi = BigInteger.fromByteArrayUnsigned(input);\r\n      var chars = [];\r\n\r\n      while (bi.compareTo(Base58.base) >= 0) {\r\n        var mod = bi.mod(Base58.base);\r\n        chars.unshift(Base58.alphabet[mod.intValue()]);\r\n        bi = bi.subtract(mod).divide(Base58.base);\r\n      }\r\n      chars.unshift(Base58.alphabet[bi.intValue()]);\r\n\r\n      // Convert leading zeros too.\r\n      for (var i = 0; i < input.length; i++) {\r\n        if (input[i] == 0x00) {\r\n          chars.unshift(Base58.alphabet[0]);\r\n        } else break;\r\n      }\r\n\r\n      return chars.join('');\r\n    },\r\n    decode: function (input) {\r\n      var bi = BigInteger.valueOf(0);\r\n      var leadingZerosNum = 0;\r\n      for (var i = input.length - 1; i >= 0; i--) {\r\n        var alphaIndex = Base58.alphabet.indexOf(input[i]);\r\n        if (alphaIndex < 0) {\r\n          throw \"Invalid character\";\r\n        }\t\r\n        bi = bi.add(BigInteger.valueOf(alphaIndex)\r\n                    .multiply(Base58.base.pow(input.length - 1 -i)));\r\n\r\n        // This counts leading zero bytes\r\n        if (input[i] == \"1\") leadingZerosNum++;\r\n        else leadingZerosNum = 0;\r\n      }\r\n      var bytes = bi.toByteArrayUnsigned();\r\n\r\n      // Add leading zeros\r\n      while (leadingZerosNum-- > 0) bytes.unshift(0);\r\n\r\n      return bytes;\r\n    }\r\n  };\r\n})();"],"sourceRoot":"/source/"}