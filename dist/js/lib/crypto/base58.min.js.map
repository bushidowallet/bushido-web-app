{"version":3,"sources":["lib/crypto/base58.js"],"names":["Base58","alphabet","validRegex","base","BigInteger","valueOf","encode","input","bi","fromByteArrayUnsigned","chars","compareTo","mod","unshift","intValue","subtract","divide","i","length","join","decode","leadingZerosNum","alphaIndex","indexOf","add","multiply","pow","bytes","toByteArrayUnsigned"],"mappings":"CAQA,WACEA,QACEC,SAAU,6DACVC,WAAY,0BACZC,KAAMC,WAAWC,QAAQ,IACzBC,OAAQ,SAAUC,GAIhB,IAHA,GAAIC,GAAKJ,WAAWK,sBAAsBF,GACtCG,KAEGF,EAAGG,UAAUX,OAAOG,OAAS,GAAG,CACrC,GAAIS,GAAMJ,EAAGI,IAAIZ,OAAOG,KACxBO,GAAMG,QAAQb,OAAOC,SAASW,EAAIE,aAClCN,EAAKA,EAAGO,SAASH,GAAKI,OAAOhB,OAAOG,MAEtCO,EAAMG,QAAQb,OAAOC,SAASO,EAAGM,YAGjC,KAAK,GAAIG,GAAI,EAAGA,EAAIV,EAAMW,QACR,GAAZX,EAAMU,GADsBA,IAE9BP,EAAMG,QAAQb,OAAOC,SAAS,GAIlC,OAAOS,GAAMS,KAAK,KAEpBC,OAAQ,SAAUb,GAGhB,IAAK,GAFDC,GAAKJ,WAAWC,QAAQ,GACxBgB,EAAkB,EACbJ,EAAIV,EAAMW,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC1C,GAAIK,GAAatB,OAAOC,SAASsB,QAAQhB,EAAMU,GAC/C,IAAiB,EAAbK,EACF,KAAM,mBAERd,GAAKA,EAAGgB,IAAIpB,WAAWC,QAAQiB,GAClBG,SAASzB,OAAOG,KAAKuB,IAAInB,EAAMW,OAAS,EAAGD,KAGxC,KAAZV,EAAMU,GAAWI,IAChBA,EAAkB,EAKzB,IAHA,GAAIM,GAAQnB,EAAGoB,sBAGRP,KAAoB,GAAGM,EAAMd,QAAQ,EAE5C,OAAOc","file":"lib/crypto/base58.min.js","sourcesContent":["/**\n * Convert a byte array to a base58-encoded string.\n *\n * Written by Mike Hearn for BitcoinJ.\n *   Copyright (c) 2011 Google Inc.\n *\n * Ported to JavaScript by Stefan Thomas.\n */\n(function () {\n  Base58 = {\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\",\n    validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,\n    base: BigInteger.valueOf(58),\n    encode: function (input) {\n      var bi = BigInteger.fromByteArrayUnsigned(input);\n      var chars = [];\n\n      while (bi.compareTo(Base58.base) >= 0) {\n        var mod = bi.mod(Base58.base);\n        chars.unshift(Base58.alphabet[mod.intValue()]);\n        bi = bi.subtract(mod).divide(Base58.base);\n      }\n      chars.unshift(Base58.alphabet[bi.intValue()]);\n\n      // Convert leading zeros too.\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] == 0x00) {\n          chars.unshift(Base58.alphabet[0]);\n        } else break;\n      }\n\n      return chars.join('');\n    },\n    decode: function (input) {\n      var bi = BigInteger.valueOf(0);\n      var leadingZerosNum = 0;\n      for (var i = input.length - 1; i >= 0; i--) {\n        var alphaIndex = Base58.alphabet.indexOf(input[i]);\n        if (alphaIndex < 0) {\n          throw \"Invalid character\";\n        }\t\n        bi = bi.add(BigInteger.valueOf(alphaIndex)\n                    .multiply(Base58.base.pow(input.length - 1 -i)));\n\n        // This counts leading zero bytes\n        if (input[i] == \"1\") leadingZerosNum++;\n        else leadingZerosNum = 0;\n      }\n      var bytes = bi.toByteArrayUnsigned();\n\n      // Add leading zeros\n      while (leadingZerosNum-- > 0) bytes.unshift(0);\n\n      return bytes;\n    }\n  };\n})();"],"sourceRoot":"/source/"}